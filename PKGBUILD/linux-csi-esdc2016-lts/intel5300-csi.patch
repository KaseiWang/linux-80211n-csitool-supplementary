diff --git a/README.md b/README.md
new file mode 100644
index 0000000..bed454f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,36 @@
+This is the git repository for Linux kernel drivers (and driver modifications)
+we use for IEEE 802.11n research.
+
+The tool was released on November 8, 2010, and was announced to the SIGCOMM
+community in the January 2011 issue of CCR.  See our tool announcement for
+more information:
+
+   Daniel Halperin, Wenjun Hu, Anmol Sheth, and David Wetherall. "Tool Release:
+   Gathering 802.11n Traces with Channel State Information." ACM SIGCOMM
+   Computer Communication Review (CCR), vol. 41, no. 1, p. 53, January 2011.
+   http://ccr.sigcomm.org/online/?q=node/719
+
+This includes the 802.11n Channel State Information (CSI) Measurement Tool we
+have used in our SIGCOMM, GLOBECOM and CCR papers:
+
+   Daniel Halperin, Wenjun Hu, Anmol Sheth, and David Wetherall. "Predictable
+   802.11 Packet Delivery from Wireless Channel Measurements." ACM SIGCOMM,
+   2010.
+
+   Daniel Halperin, Wenjun Hu, Anmol Sheth, and David Wetherall. "802.11n With
+   Multiple Antenna For Dummies." ACM SIGCOMM Computer Communication Review
+   (CCR), vol. 40, no. 1, pp. 19â€“25, January 2010.
+
+   Eldad Perahia, Anmol Sheth, Thomas Kenney, Robert Stacey, and Daniel
+   Halperin. "Investigation into the Doppler component of the IEEE 802.11n
+   channel model." IEEE GLOBECOM -- Wireless Communications, 2010.
+
+For more information, see our project website at:
+
+   http://r.halper.in/url/csitool
+
+Contact:
+
+   Daniel Halperin   ---   dhalperi@cs.washington.edu
+   Graduate Student, University of Washington Computer Science and Engineering
+   http://r.halper.in/work
diff --git a/drivers/net/wireless/iwlwifi/Kconfig b/drivers/net/wireless/iwlwifi/Kconfig
index f89f446..73b5973 100644
--- a/drivers/net/wireless/iwlwifi/Kconfig
+++ b/drivers/net/wireless/iwlwifi/Kconfig
@@ -52,6 +52,7 @@ config IWLWIFI_LEDS
 
 config IWLDVM
 	tristate "Intel Wireless WiFi DVM Firmware support"
+	depends on CONNECTOR
 	default IWLWIFI
 	help
 	  This is the driver that supports the DVM firmware which is
diff --git a/drivers/net/wireless/iwlwifi/dvm/Makefile b/drivers/net/wireless/iwlwifi/dvm/Makefile
index 4d19685..a23126c 100644
--- a/drivers/net/wireless/iwlwifi/dvm/Makefile
+++ b/drivers/net/wireless/iwlwifi/dvm/Makefile
@@ -4,7 +4,7 @@ iwldvm-objs		+= main.o rs.o mac80211.o ucode.o tx.o
 iwldvm-objs		+= lib.o calib.o tt.o sta.o rx.o
 
 iwldvm-objs		+= power.o
-iwldvm-objs		+= scan.o
+iwldvm-objs		+= scan.o connector.o
 iwldvm-objs		+= rxon.o devices.o
 
 iwldvm-$(CONFIG_IWLWIFI_LEDS) += led.o
diff --git a/drivers/net/wireless/iwlwifi/dvm/agn.h b/drivers/net/wireless/iwlwifi/dvm/agn.h
index c160dad..accd95b 100644
--- a/drivers/net/wireless/iwlwifi/dvm/agn.h
+++ b/drivers/net/wireless/iwlwifi/dvm/agn.h
@@ -221,6 +221,8 @@ int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv,
 				   struct iwl_device_cmd *cmd);
 int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
 			       struct iwl_device_cmd *cmd);
+int iwlagn_bfee_notif(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
+		      struct iwl_device_cmd *cmd);
 
 static inline u32 iwl_tx_status_to_mac80211(u32 status)
 {
@@ -489,4 +491,13 @@ static inline const char *iwl_dvm_get_cmd_string(u8 cmd)
 		return s;
 	return "UNKNOWN";
 }
+
+extern const u8 iwl_monitor_addr[ETH_ALEN];
+static inline bool is_monitor_ether_addr(const u8 *addr)
+{
+	if (WARN_ON(addr == NULL))
+		return 0;
+	return !memcmp(addr, iwl_monitor_addr, ETH_ALEN);
+}
+
 #endif /* __iwl_agn_h__ */
diff --git a/drivers/net/wireless/iwlwifi/dvm/commands.h b/drivers/net/wireless/iwlwifi/dvm/commands.h
index 7a34e4d..9d198c1 100644
--- a/drivers/net/wireless/iwlwifi/dvm/commands.h
+++ b/drivers/net/wireless/iwlwifi/dvm/commands.h
@@ -158,6 +158,10 @@ enum {
 	REPLY_CT_KILL_CONFIG_CMD = 0xa4,
 	SENSITIVITY_CMD = 0xa8,
 	REPLY_PHY_CALIBRATION_CMD = 0xb0,
+
+	/* Beamforming */
+	REPLY_BFEE_NOTIFICATION = 0xbb,
+
 	REPLY_RX_PHY_CMD = 0xc0,
 	REPLY_RX_MPDU_CMD = 0xc1,
 	REPLY_RX = 0xc3,
@@ -187,6 +191,9 @@ enum {
 	REPLY_WOWLAN_GET_STATUS = 0xe5,
 	REPLY_D3_CONFIG = 0xd3,
 
+	/* Gets metadata for Beamforming */
+	DSP_DEBUG_CMD = 0xf1,
+
 	REPLY_MAX = 0xff
 };
 
@@ -578,6 +585,10 @@ enum {
 #define RXON_FLG_CHANNEL_MODE_PURE_40	cpu_to_le32(CHANNEL_MODE_PURE_40 << RXON_FLG_CHANNEL_MODE_POS)
 #define RXON_FLG_CHANNEL_MODE_MIXED	cpu_to_le32(CHANNEL_MODE_MIXED << RXON_FLG_CHANNEL_MODE_POS)
 
+/* Beamforming */
+#define RXON_FLG_BF_ENABLE_POS			(29)
+#define RXON_FLG_BF_ENABLE_MSK			cpu_to_le32(0x1<<29)
+
 /* CTS to self (if spec allows) flag */
 #define RXON_FLG_SELF_CTS_EN			cpu_to_le32(0x1<<30)
 
@@ -789,6 +800,7 @@ struct iwl_qosparam_cmd {
 #define	IWL_AP_ID		0
 #define	IWL_AP_ID_PAN		1
 #define	IWL_STA_ID		2
+#define IWLAGN_MONITOR_ID	13
 #define IWLAGN_PAN_BCAST_ID	14
 #define IWLAGN_BROADCAST_ID	15
 #define	IWLAGN_STATION_COUNT	16
@@ -1096,6 +1108,7 @@ struct iwl_wep_cmd {
 #define IWLAGN_OFDM_RSSI_INBAND_C_BITMSK 0x00ff
 #define IWLAGN_OFDM_RSSI_ALLBAND_C_BITMSK 0xff00
 #define IWLAGN_OFDM_RSSI_C_BIT_POS 0
+#define IWLAGN_MAX_CFG_PHY_CNT 20
 
 struct iwlagn_non_cfg_phy {
 	__le32 non_cfg_phy[IWLAGN_RX_RES_PHY_CNT];  /* up to 8 phy entries */
@@ -1108,7 +1121,7 @@ struct iwlagn_non_cfg_phy {
  */
 struct iwl_rx_phy_res {
 	u8 non_cfg_phy_cnt;     /* non configurable DSP phy data byte count */
-	u8 cfg_phy_cnt;		/* configurable DSP phy data byte count */
+	u8 cfg_phy_cnt;		/* configurable DSP phy data element count */
 	u8 stat_id;		/* configurable DSP phy data set ID */
 	u8 reserved1;
 	__le64 timestamp;	/* TSF at on air rise */
@@ -1119,6 +1132,7 @@ struct iwl_rx_phy_res {
 	__le32 rate_n_flags;	/* RATE_MCS_* */
 	__le16 byte_count;	/* frame's byte-count */
 	__le16 frame_time;	/* frame's time on the air */
+	u8 cfg_phy_buf[0];	/* The values requested via DSP_DEBUG */
 } __packed;
 
 struct iwl_rx_mpdu_res_start {
@@ -3910,6 +3924,62 @@ struct iwlagn_wowlan_status {
 	__le16 reserved3;
 } __packed;
 
+/******************************************************************************
+ * (14)
+ * Beamforming commands
+ *
+ *****************************************************************************/
+
+/*
+ * REPLY_BFEE_NOTIFICATION = 0xbb
+ *
+ */
+struct iwl_bfee_notif {
+	__le32 timestamp_low;
+	__le16 bfee_count;
+	__le16 reserved1;
+	u8 Nrx, Ntx;
+	u8 rssiA, rssiB, rssiC;
+	s8 noise;
+	u8 agc, antenna_sel;
+	__le16 len;
+	__le16 fake_rate_n_flags;
+	u8 payload[0];
+} __attribute__ ((packed));
+
+/******************************************************************************
+ * (15)
+ * DSP debug interface
+ *
+ *****************************************************************************/
+
+/* DSP debugging */
+#define DSP_DEBUG_CCK_MSK		(0x1)
+#define DSP_DEBUG_OFDM_MSK		(0x0)
+/* MIB values */
+#define OFDM_RX_ANT_OUT			0x4302
+
+/*
+ * DSP_DEBUG_CMD = 0xf1
+ *
+ */
+struct iwl5000_dsp_debug {
+	u8 mib_cnt;
+	u8 flags;
+	u8 stat_id;
+	u8 reserved;
+	u16 mib_indices[0];
+} __attribute__ ((packed));
+
+/* For rotate rates */
+#define ROTATE_SISO	1
+#define ROTATE_MIMO2	2
+#define ROTATE_MIMO3	4
+#define ROTATE_TX_SEL	8
+#define ROTATE_HT40	16
+#define ROTATE_SGI	32
+#define ROTATE_SKIP	64
+
 /*
  * REPLY_WIPAN_PARAMS = 0xb2 (Commands and Notification)
  */
diff --git a/drivers/net/wireless/iwlwifi/dvm/connector.c b/drivers/net/wireless/iwlwifi/dvm/connector.c
new file mode 100644
index 0000000..c2645eb
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/dvm/connector.c
@@ -0,0 +1,207 @@
+/******************************************************************************
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008-2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ * Daniel Halperin <dhalperi@cs.washington.edu>
+ * University of Washington CSE, 185 Stevens Way AC101, Seattle, WA 98195-2350
+ * Anmol Sheth <anmol.n.sheth@intel.com>
+ * Intel Labs Seattle, 1100 NE 45th St, Seattle, WA 98105
+ *
+ *****************************************************************************/
+
+#include "connector.h"
+#include <linux/export.h>
+
+/**
+ * This struct is required for the connector interface to be set up.
+ */
+struct cb_id connector_id = {
+	.idx = CN_IDX_IWLAGN,
+	.val = CN_VAL_IWLAGN,
+};
+EXPORT_SYMBOL(connector_id);
+char *connector_name = "iwlagn";
+EXPORT_SYMBOL(connector_name);
+static struct work_struct connector_work_s;
+
+static struct iwl_priv *priv;
+static spinlock_t connector_lock;
+
+#define CN_BUF_SIZE	1024
+static struct cn_msg *cn_msg_buf[CN_BUF_SIZE];
+static u32 cn_buf_read, cn_buf_write;
+
+/**
+ * Enqueues a connector message into the buffer. Will drop and free if full.
+ */
+static void connector_enqueue_msg(struct cn_msg *m)
+{
+	unsigned long flags;
+	u32 start, end;
+
+	/* Get read and write indices */
+	spin_lock_irqsave(&connector_lock, flags);
+	start = cn_buf_read;
+	end = cn_buf_write;
+	spin_unlock_irqrestore(&connector_lock, flags);
+
+	/* Make sure space for message */
+	if ((end + 1) % CN_BUF_SIZE == start) {
+		printk(KERN_ERR "%s: buffer full; connector message dropped\n",
+				__func__);
+		kfree(m);
+		return;
+	}
+
+	/* Make sure priv is known */
+	if (priv == NULL) {
+		printk(KERN_ERR "%s: priv is NULL\n", __func__);
+		kfree(m);
+		return;
+	}
+
+	/* Enqueue message */
+	cn_msg_buf[end] = m;
+	spin_lock_irqsave(&connector_lock, flags);
+	cn_buf_write = (end + 1) % CN_BUF_SIZE;
+	spin_unlock_irqrestore(&connector_lock, flags);
+
+	/* Schedule tasklet */
+	queue_work(priv->workqueue, &connector_work_s);
+}
+
+/**
+ * Sends and frees all the queued messages.
+ */
+static void connector_send_all(void)
+{
+	u32 i;
+	unsigned long flags;
+	u32 start, end;
+
+	/* Get current index */
+	spin_lock_irqsave(&connector_lock, flags);
+	start = cn_buf_read;
+	end = cn_buf_write;
+	spin_unlock_irqrestore(&connector_lock, flags);
+
+	/* Loop through buffer sending messages */
+	for (i = start; i != end; i = ((i+1) % CN_BUF_SIZE)) {
+		cn_netlink_send(cn_msg_buf[i], 0, 0, GFP_ATOMIC);
+		kfree(cn_msg_buf[i]);
+	}
+
+	/* Set index back to zero, if it has reached 1024 */
+	spin_lock_irqsave(&connector_lock, flags);
+	cn_buf_read = end;
+	spin_unlock_irqrestore(&connector_lock, flags);
+}
+static void connector_work(struct work_struct *trash)
+{
+	connector_send_all();
+}
+
+/**
+ * Sends the message over the kernel connector to a userspace program.
+ */
+void connector_send_msg(const u8 *data, const u32 size, const u8 code)
+{
+	struct cn_msg *m;
+	u8 *buf;
+	u32 payload_size;
+
+	/* Payload + 1-byte "code" */
+	payload_size = size + 1 + sizeof(struct cn_msg);
+	m = kmalloc(payload_size, GFP_ATOMIC);
+	if (m == NULL) {
+		printk(KERN_ERR "%s: malloc failed\n", __func__);
+		return;
+	}
+	buf = ((u8 *) m) + sizeof(struct cn_msg);
+
+	/* Set up message */
+	memcpy(&m->id, &connector_id, sizeof(struct cb_id));
+	m->seq = 0;
+	m->len = size + 1;
+	buf[0] = code;
+	memcpy(&buf[1], data, size);
+
+	/* Enqueue message -- may free on failure */
+	connector_enqueue_msg(m);
+
+	return;
+}
+EXPORT_SYMBOL(connector_send_msg);
+
+void connector_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)
+{
+	printk(KERN_ERR "%s: %lu: unhandled message idx=%x, val=%x, seq=%u, ack=%u, len=%d.\n",
+		__func__, jiffies, msg->id.idx, msg->id.val,
+	msg->seq, msg->ack, msg->len);
+}
+EXPORT_SYMBOL(connector_callback);
+int iwlagn_register_connector(void)
+{
+	int ret;
+
+	/* Try and setup the connector callback */
+	ret = cn_add_callback(&connector_id, connector_name,
+			connector_callback);
+	if (ret)
+		return ret;
+
+	/* Init connector message queue, lock, and tasklet */
+	cn_buf_read = 0;
+	cn_buf_write = 0;
+	spin_lock_init(&connector_lock);
+	INIT_WORK(&connector_work_s, connector_work);
+
+	printk(KERN_INFO "iwlagn: connector callback registered\n");
+	return 0;
+}
+EXPORT_SYMBOL(iwlagn_register_connector);
+void iwlagn_unregister_connector(void)
+{
+	u32 i;
+	unsigned long flags;
+
+	/* Reset the connector state */
+	spin_lock_irqsave(&connector_lock, flags);
+	for (i = cn_buf_read; i != cn_buf_write; i = (i+1) % CN_BUF_SIZE)
+		kfree(cn_msg_buf[i]);
+	spin_unlock_irqrestore(&connector_lock, flags);
+
+	/* Deregister connector */
+	cn_del_callback(&connector_id);
+	printk(KERN_INFO "iwlagn: connector callback deregistered\n");
+}
+EXPORT_SYMBOL(iwlagn_unregister_connector);
+void iwl_connector_set_priv(struct iwl_priv *p)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&connector_lock, flags);
+	priv = p;
+	spin_unlock_irqrestore(&connector_lock, flags);
+}
+EXPORT_SYMBOL(iwl_connector_set_priv);
diff --git a/drivers/net/wireless/iwlwifi/dvm/connector.h b/drivers/net/wireless/iwlwifi/dvm/connector.h
new file mode 100644
index 0000000..703551b
--- /dev/null
+++ b/drivers/net/wireless/iwlwifi/dvm/connector.h
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008-2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
+ * USA
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ * Daniel Halperin <dhalperi@cs.washington.edu>
+ * University of Washington CSE, 185 Stevens Way AC101, Seattle, WA 98195-2350
+ * Anmol Sheth <anmol.n.sheth@intel.com>
+ * Intel Labs Seattle, 1100 NE 45th St, Seattle, WA 98105
+ *
+ *****************************************************************************/
+
+/**
+ * This file defines the connector interface.
+ */
+
+#ifndef __iwl_connector_h__
+#define __iwl_connector_h__
+
+#include <linux/etherdevice.h>
+#include <net/mac80211.h>
+#include <asm/unaligned.h>
+#include <linux/connector.h>
+#include "dev.h"
+#include "commands.h"
+
+extern struct cb_id connector_id;
+extern char *connector_name;
+
+void connector_send_msg(const u8 *data, const u32 size, const u8 code);
+void iwl_connector_set_priv(struct iwl_priv *p);
+void connector_tasklet(unsigned long trash);
+
+#define CN_IDX_IWLAGN	(CN_NETLINK_USERS + 0xf)
+#define CN_VAL_IWLAGN	0x1
+
+#define IWL_CONN_BFEE_NOTIF	REPLY_BFEE_NOTIFICATION		/* 0xbb */
+#define IWL_CONN_RX_PHY		REPLY_RX_PHY_CMD		/* 0xc0 */
+#define IWL_CONN_RX_MPDU	REPLY_RX_MPDU_CMD		/* 0xc1 */
+#define IWL_CONN_RX		REPLY_RX			/* 0xc3 */
+#define IWL_CONN_NOISE		0xd0		/* new ID not a command */
+#define IWL_CONN_TX_RESP	REPLY_TX			/* 0x1c */
+#define IWL_CONN_TX_BLOCK_AGG	REPLY_COMPRESSED_BA		/* 0xc5 */
+#define IWL_CONN_STATUS		0xd1		/* new ID not a command */
+
+enum {
+	IWL_CONN_BFEE_NOTIF_MSK		= (1 << 0),
+	IWL_CONN_RX_PHY_MSK		= (1 << 1),
+	IWL_CONN_RX_MPDU_MSK		= (1 << 2),
+	IWL_CONN_RX_MSK			= (1 << 3),
+	IWL_CONN_NOISE_MSK		= (1 << 4),
+	IWL_CONN_TX_RESP_MSK		= (1 << 5),
+	IWL_CONN_TX_BLOCK_AGG_MSK	= (1 << 6),
+	IWL_CONN_STATUS_MSK		= (1 << 7),
+};
+
+void connector_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp);
+int iwlagn_register_connector(void);
+void iwlagn_unregister_connector(void);
+
+/*
+ * Struct to send TX block aggregation information down to the host.
+ */
+struct tx_agg_ba_connector_msg {
+	u32 successes;
+	u32 frame_count;
+};
+
+#endif /* __iwl_connector_h__ */
diff --git a/drivers/net/wireless/iwlwifi/dvm/debugfs.c b/drivers/net/wireless/iwlwifi/dvm/debugfs.c
index 0ffb6ff..2b11b82 100644
--- a/drivers/net/wireless/iwlwifi/dvm/debugfs.c
+++ b/drivers/net/wireless/iwlwifi/dvm/debugfs.c
@@ -2353,6 +2353,318 @@ DEBUGFS_READ_WRITE_FILE_OPS(log_event);
 #endif
 DEBUGFS_READ_WRITE_FILE_OPS(calib_disabled);
 
+static ssize_t iwl_dbgfs_bf_flag_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	int len;
+
+	len = scnprintf(buf, sizeof(buf), "%d", priv->bf_enabled);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t iwl_dbgfs_bf_flag_write(struct file *file,
+					   const char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	unsigned long val;
+	int ret;
+
+	if (count > sizeof(buf))
+		return -EINVAL;
+
+	memset(buf, 0, sizeof(buf));
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	priv->bf_enabled = !!val;
+
+	return count;
+}
+DEBUGFS_READ_WRITE_FILE_OPS(bf_flag);
+
+static ssize_t iwl_dbgfs_rx_chains_msk_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[128];
+	int len;
+
+	len = scnprintf(buf, sizeof(buf), "rx_chains: %d antennas, mask 0x%x",
+			priv->hw_params.rx_chains_num,
+			priv->nvm_data->valid_rx_ant);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t iwl_dbgfs_rx_chains_msk_write(struct file *file,
+					   const char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	struct iwl_rxon_context *ctx;
+	char buf[11];
+	unsigned long val;
+	int ret;
+
+	if (count > sizeof(buf))
+		return -EINVAL;
+
+	memset(buf, 0, sizeof(buf));
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if ((val & ANT_ABC) != val) {
+		IWL_ERR(priv, "Invalid rx ant mask 0x%lx\n", val);
+		return -EINVAL;
+	}
+	IWL_INFO(priv, "Committing rx_chains_msk = 0x%lx\n", val);
+
+	mutex_lock(&priv->mutex);
+	/* Update chains and number of chains */
+	priv->nvm_data->valid_rx_ant = val;
+	priv->hw_params.rx_chains_num = num_of_ant(val);
+	/* This is useful for verifying valid rates */
+	priv->chain_noise_data.active_chains = val;
+
+	for_each_context(priv, ctx) {
+		iwlagn_set_rxon_chain(priv, ctx);
+		iwlagn_commit_rxon(priv, ctx);
+	}
+	mutex_unlock(&priv->mutex);
+
+	return count;
+}
+DEBUGFS_READ_WRITE_FILE_OPS(rx_chains_msk);
+
+static ssize_t iwl_dbgfs_rotate_rates_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	int len;
+
+	len = scnprintf(buf, sizeof(buf), "0x%x", priv->rotate_rates);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t iwl_dbgfs_rotate_rates_write(struct file *file,
+					   const char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	unsigned long val;
+	int ret;
+	u32 num_rates;
+	u32 cur_rate;
+	u32 tmp, i, start_rate;
+
+	if (count > sizeof(buf))
+		return -EINVAL;
+
+	memset(buf, 0, sizeof(buf));
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	/* Dan: new rotate_rates scheme using flags */
+	if (priv->rotate_rates) {
+		kfree(priv->rotate_rate_array);
+		priv->rotate_rate_array = NULL;
+		priv->last_rotate_rate = 0;
+		priv->rotate_rate_total = 0;
+		priv->rotate_rates = 0;
+	}
+
+	if (val == 0)
+		return count;
+
+	/* Parse val to determine number of configs */
+	num_rates = 0;
+	if (val & ROTATE_SISO) /* SISO */
+		num_rates++;
+	if (val & ROTATE_MIMO2) /* MIMO2 */
+		num_rates++;
+	if (val & ROTATE_MIMO3) /* MIMO3 */
+		num_rates++;
+	if (val & ROTATE_TX_SEL) /* TX SEL */ {
+		if (val & ROTATE_SISO) num_rates += 2;
+		if (val & ROTATE_MIMO2) num_rates += 2;
+	}
+	if (val & ROTATE_HT40) /* HT40 */
+		num_rates *= 2;
+	if (val & ROTATE_SGI) /* SGI */
+		num_rates *= 2;
+	if (val & ROTATE_SKIP) /* SKIP short rates */ {
+		num_rates *= 6;
+		start_rate = 2;
+	} else {
+		num_rates *= 8;
+		start_rate = 0;
+	}
+
+	/* Shouldn't be true but may as well make sure */
+	if (num_rates == 0)
+		return -EINVAL;
+
+	/* Now set up rotate_rate_array */
+	priv->rotate_rate_array = kmalloc(num_rates * sizeof(u32),
+			GFP_KERNEL);
+	if (!priv->rotate_rate_array)
+		return -ENOMEM;
+	priv->rotate_rates = 1;
+	priv->last_rotate_rate = 0;
+	priv->rotate_rate_total = num_rates;
+
+	cur_rate = 0;
+	if (val & ROTATE_SISO) /* SISO rates */
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0x4100 + i;
+	if (val & ROTATE_MIMO2) /* MIMO2 rates */
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0xc108 + i;
+	if (val & ROTATE_MIMO3) /* MIMO3 rates */
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0x1c110 + i;
+	if ((val & ROTATE_TX_SEL) && (val & ROTATE_SISO)) {
+		/* TX SEL SISO rates */
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0x8100 + i;
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0x10100 + i;
+	}
+	if ((val & ROTATE_TX_SEL) && (val & ROTATE_MIMO2)) {
+		/* TX SEL MIMO2 rates */
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0x14108 + i;
+		for (i = start_rate; i < 8; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] = 0x18108 + i;
+	}
+	if (val & ROTATE_HT40) { /* HT40 rates */
+		tmp = cur_rate;
+		for (i = start_rate; i < tmp; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] =
+				priv->rotate_rate_array[i] | RATE_MCS_HT40_MSK;
+	}
+	if (val & ROTATE_SGI) { /* SGI rates */
+		tmp = cur_rate;
+		for (i = start_rate; i < tmp; ++i, ++cur_rate)
+			priv->rotate_rate_array[cur_rate] =
+				priv->rotate_rate_array[i] | RATE_MCS_SGI_MSK;
+	}
+
+	IWL_INFO(priv, "Set up %u rotate_rates:%s%s%s%s%s%s%s.\n",
+			priv->rotate_rate_total,
+			(val & ROTATE_SISO) ? " SISO" : "",
+			(val & ROTATE_MIMO2) ? " MIMO2" : "",
+			(val & ROTATE_MIMO3) ? " MIMO3" : "",
+			(val & ROTATE_TX_SEL) ? " TX_SEL" : "",
+			(val & ROTATE_HT40) ? " HT40" : "",
+			(val & ROTATE_SGI) ? " SGI" : "",
+			(val & ROTATE_SKIP) ? " SKIP" : "");
+
+	return count;
+}
+DEBUGFS_READ_WRITE_FILE_OPS(rotate_rates);
+
+static ssize_t iwl_dbgfs_monitor_tx_rate_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	int len;
+
+	len = scnprintf(buf, sizeof(buf), "0x%x", priv->monitor_tx_rate);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t iwl_dbgfs_monitor_tx_rate_write(struct file *file,
+					   const char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	unsigned long val;
+	int ret;
+
+	if (count > sizeof(buf))
+		return -EINVAL;
+
+	memset(buf, 0, sizeof(buf));
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	priv->monitor_tx_rate = val;
+
+	return count;
+}
+DEBUGFS_READ_WRITE_FILE_OPS(monitor_tx_rate);
+
+static ssize_t iwl_dbgfs_bcast_tx_rate_read(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	int len;
+
+	len = scnprintf(buf, sizeof(buf), "0x%x", priv->bcast_tx_rate);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t iwl_dbgfs_bcast_tx_rate_write(struct file *file,
+					   const char __user *user_buf,
+					   size_t count, loff_t *ppos)
+{
+	struct iwl_priv *priv = file->private_data;
+	char buf[11];
+	unsigned long val;
+	int ret;
+
+	if (count > sizeof(buf))
+		return -EINVAL;
+
+	memset(buf, 0, sizeof(buf));
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	priv->bcast_tx_rate = val;
+
+	return count;
+}
+DEBUGFS_READ_WRITE_FILE_OPS(bcast_tx_rate);
+
 /*
  * Create the debugfs files and directories
  *
@@ -2412,6 +2724,11 @@ int iwl_dbgfs_register(struct iwl_priv *priv, struct dentry *dbgfs_dir)
 
 	if (iwl_advanced_bt_coexist(priv))
 		DEBUGFS_ADD_FILE(bt_traffic, dir_debug, S_IRUSR);
+	DEBUGFS_ADD_FILE(bf_flag, dir_debug, S_IRUSR | S_IWUSR);
+	DEBUGFS_ADD_FILE(rx_chains_msk, dir_debug, S_IRUSR | S_IWUSR);
+	DEBUGFS_ADD_FILE(rotate_rates, dir_debug, S_IRUSR | S_IWUSR);
+	DEBUGFS_ADD_FILE(monitor_tx_rate, dir_debug, S_IRUSR | S_IWUSR);
+	DEBUGFS_ADD_FILE(bcast_tx_rate, dir_debug, S_IRUSR | S_IWUSR);
 
 	/* Calibrations disabled/enabled status*/
 	DEBUGFS_ADD_FILE(calib_disabled, dir_rf, S_IWUSR | S_IRUSR);
diff --git a/drivers/net/wireless/iwlwifi/dvm/dev.h b/drivers/net/wireless/iwlwifi/dvm/dev.h
index 3811878..71394bc 100644
--- a/drivers/net/wireless/iwlwifi/dvm/dev.h
+++ b/drivers/net/wireless/iwlwifi/dvm/dev.h
@@ -283,7 +283,7 @@ extern const u8 iwl_bcast_addr[ETH_ALEN];
 /* Sensitivity and chain noise calibration */
 #define INITIALIZATION_VALUE		0xFFFF
 #define IWL_CAL_NUM_BEACONS		16
-#define MAXIMUM_ALLOWED_PATHLOSS	15
+#define MAXIMUM_ALLOWED_PATHLOSS	50
 
 #define CHAIN_NOISE_MAX_DELTA_GAIN_CODE 3
 
@@ -808,6 +808,7 @@ struct iwl_priv {
 	u8 agg_tids_count;
 
 	struct iwl_rx_phy_res last_phy_res;
+	u8 last_cfg_phy_buf[IWLAGN_MAX_CFG_PHY_CNT*sizeof(u32)];
 	u32 ampdu_ref;
 	bool last_phy_res_valid;
 
@@ -874,6 +875,21 @@ struct iwl_priv {
 	void *wowlan_sram;
 #endif /* CONFIG_IWLWIFI_DEBUGFS */
 
+	u32 connector_log;
+	int last_rx_noise;
+	s8 last_rx_noiseA;
+	s8 last_rx_noiseB;
+	s8 last_rx_noiseC;
+	bool bf_enabled;
+	u32 monitor_tx_rate;
+	u32 bcast_tx_rate;
+
+	/* Setup for rotating rates */
+	u32 rotate_rates;
+	u32 last_rotate_rate;
+	u32 rotate_rate_total;
+	u32 *rotate_rate_array;
+
 	struct iwl_nvm_data *nvm_data;
 	/* eeprom blob for debugfs */
 	u8 *eeprom_blob;
diff --git a/drivers/net/wireless/iwlwifi/dvm/lib.c b/drivers/net/wireless/iwlwifi/dvm/lib.c
index 1d2223d..e2a1e51 100644
--- a/drivers/net/wireless/iwlwifi/dvm/lib.c
+++ b/drivers/net/wireless/iwlwifi/dvm/lib.c
@@ -39,6 +39,82 @@
 
 #include "dev.h"
 #include "agn.h"
+#include "connector.h"
+
+int iwlagn_bfee_notif(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,
+		struct iwl_device_cmd *cmd)
+{
+	/*
+	 * Just print a notification that there was a notification passed up
+	 * from SVD
+	 */
+	struct iwl_rx_packet *pkt = rxb_addr(rxb);
+	struct iwl_bfee_notif *bfee_notif = (void *)pkt->data;
+	u8 Nrx, Ntx;
+	u16 len = le16_to_cpu(bfee_notif->len);
+	struct iwl_rx_phy_res *phy;
+	u32 *non_cfg_buf, *cfg_buf;
+	static u16 bfee_count;
+
+	if (priv->last_phy_res_valid) {
+		phy = &priv->last_phy_res;
+		non_cfg_buf = (u32 *)phy->non_cfg_phy_buf;
+		bfee_notif->timestamp_low =
+			cpu_to_le32(__le64_to_cpu(phy->timestamp));
+		bfee_notif->rssiA =
+			(non_cfg_buf[IWLAGN_RX_RES_RSSI_AB_IDX] &
+			 IWLAGN_OFDM_RSSI_INBAND_A_BITMSK) >>
+			IWLAGN_OFDM_RSSI_A_BIT_POS;
+		bfee_notif->rssiB =
+			(non_cfg_buf[IWLAGN_RX_RES_RSSI_AB_IDX] &
+			 IWLAGN_OFDM_RSSI_INBAND_B_BITMSK) >>
+			IWLAGN_OFDM_RSSI_B_BIT_POS;
+		bfee_notif->rssiC =
+			(non_cfg_buf[IWLAGN_RX_RES_RSSI_C_IDX] &
+			 IWLAGN_OFDM_RSSI_INBAND_C_BITMSK) >>
+			IWLAGN_OFDM_RSSI_C_BIT_POS;
+		bfee_notif->noise = priv->last_rx_noise;
+		bfee_notif->agc =
+			(non_cfg_buf[IWLAGN_RX_RES_AGC_IDX] &
+			 IWLAGN_OFDM_AGC_MSK) >> IWLAGN_OFDM_AGC_BIT_POS;
+		if (phy->cfg_phy_cnt > 0) {
+			cfg_buf = (u32 *)&priv->last_cfg_phy_buf;
+			bfee_notif->antenna_sel = cfg_buf[0];
+		}
+		/* Everything but antennas is in bottom 14 bits */
+		bfee_notif->fake_rate_n_flags =
+			cpu_to_le16(__le32_to_cpu(phy->rate_n_flags) & 0x3fff);
+		IWL_INFO(priv, "rssis: %u %u %u noise: %d agc: %u "
+				"antenna_sel: %02x fake_rate_n_flags=0x%x\n",
+				bfee_notif->rssiA, bfee_notif->rssiB,
+				bfee_notif->rssiC, bfee_notif->noise,
+				bfee_notif->agc, bfee_notif->antenna_sel,
+				bfee_notif->fake_rate_n_flags);
+
+		/* Increment counter */
+		bfee_count++;
+		bfee_notif->bfee_count = cpu_to_le16(bfee_count);
+	}
+
+	/* Log the bytes to a file */
+	if (priv->connector_log & IWL_CONN_BFEE_NOTIF_MSK)
+		connector_send_msg((void *)bfee_notif,
+			len + sizeof(struct iwl_bfee_notif),
+			IWL_CONN_BFEE_NOTIF);
+
+	/* Now print out that we got a notification, and the size of it */
+	Nrx = bfee_notif->Nrx;
+	Ntx = bfee_notif->Ntx;
+	/*
+	 * Each subcarrier uses Ntx * Nrx * 2 * 8 bits for matrix
+	 * (2 signed 8-bit I/Q vals) plus 3 bits for SNR. I think the hardware
+	 * always gives 0 for these 3 bits. See 802.11n spec section 7.3.1.28.
+	 */
+	IWL_DEBUG_RX(priv, "BFEE NOTIFICATION, Nrx=%u Ntx=%u "
+			"len=%u calc_len=%u\n",
+			Nrx, Ntx, len, (30*(3+2*Nrx*Ntx*8)+7)/8);
+	return 0;
+}
 
 int iwlagn_hw_valid_rtc_data_addr(u32 addr)
 {
diff --git a/drivers/net/wireless/iwlwifi/dvm/main.c b/drivers/net/wireless/iwlwifi/dvm/main.c
index 234e30f..6c9ffad 100644
--- a/drivers/net/wireless/iwlwifi/dvm/main.c
+++ b/drivers/net/wireless/iwlwifi/dvm/main.c
@@ -56,6 +56,7 @@
 #include "dev.h"
 #include "calib.h"
 #include "agn.h"
+#include "connector.h"
 
 
 /******************************************************************************
@@ -552,7 +553,7 @@ static void iwl_init_context(struct iwl_priv *priv, u32 ucode_flags)
 	priv->contexts[IWL_RXON_CTX_BSS].exclusive_interface_modes =
 		BIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_MONITOR);
 	priv->contexts[IWL_RXON_CTX_BSS].interface_modes =
-		BIT(NL80211_IFTYPE_STATION);
+		BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP);
 	priv->contexts[IWL_RXON_CTX_BSS].ap_devtype = RXON_DEV_TYPE_AP;
 	priv->contexts[IWL_RXON_CTX_BSS].ibss_devtype = RXON_DEV_TYPE_IBSS;
 	priv->contexts[IWL_RXON_CTX_BSS].station_devtype = RXON_DEV_TYPE_ESS;
@@ -786,6 +787,8 @@ int iwl_alive_start(struct iwl_priv *priv)
 	/* At this point, the NIC is initialized and operational */
 	iwl_rf_kill_ct_config(priv);
 
+	iwl_connector_set_priv(priv);
+
 	IWL_DEBUG_INFO(priv, "ALIVE processing complete.\n");
 
 	return iwl_power_update_mode(priv, true);
@@ -1038,6 +1041,16 @@ static int iwl_init_drv(struct iwl_priv *priv)
 	priv->missed_beacon_threshold = IWL_MISSED_BEACON_THRESHOLD_DEF;
 	priv->agg_tids_count = 0;
 
+	/* Dan's parameters */
+	priv->connector_log = iwlwifi_mod_params.connector_log;
+	priv->bf_enabled = 1;		/* Enabled */
+	priv->rotate_rates = 0;		/* Disabled */
+	priv->last_rotate_rate = 0;	/* Disabled */
+	priv->rotate_rate_total = 0;	/* Disabled */
+	priv->rotate_rate_array = NULL;	/* Disabled */
+	priv->monitor_tx_rate = 0;	/* Disabled */
+	priv->bcast_tx_rate = 0;	/* Disabled */
+
 	priv->rx_statistics_jiffies = jiffies;
 
 	/* Choose which receivers/antennas to use */
@@ -1158,6 +1171,7 @@ static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,
 		REPLY_COMPRESSED_BA,
 		STATISTICS_NOTIFICATION,
 		REPLY_TX,
+		REPLY_BFEE_NOTIFICATION,
 	};
 	int i;
 
@@ -2071,19 +2085,33 @@ static int __init iwl_init(void)
 		return ret;
 	}
 
+	ret = iwlagn_register_connector();
+	if (ret) {
+		pr_err("Unable to initialize connector: %d\n", ret);
+		goto error_connector_register;
+	}
+
 	ret = iwl_opmode_register("iwldvm", &iwl_dvm_ops);
 	if (ret) {
 		pr_err("Unable to register op_mode: %d\n", ret);
-		iwlagn_rate_control_unregister();
+		goto error_opmode_register;
 	}
 
 	return ret;
+
+error_opmode_register:
+	iwlagn_unregister_connector();
+error_connector_register:
+	iwlagn_rate_control_unregister();
+
+	return ret;
 }
 module_init(iwl_init);
 
 static void __exit iwl_exit(void)
 {
 	iwl_opmode_deregister("iwldvm");
+	iwlagn_unregister_connector();
 	iwlagn_rate_control_unregister();
 }
 module_exit(iwl_exit);
diff --git a/drivers/net/wireless/iwlwifi/dvm/rs.c b/drivers/net/wireless/iwlwifi/dvm/rs.c
index 3bd7c86..6e4e949 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rs.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rs.c
@@ -919,6 +919,10 @@ static void rs_tx_status(void *priv_r, struct ieee80211_supported_band *sband,
 		return;
 	}
 
+	/* Exit if in a fixed-rate mode */
+	if (priv && priv->rotate_rates)
+		return;
+
 	if (!ieee80211_is_data(hdr->frame_control) ||
 	    info->flags & IEEE80211_TX_CTL_NO_ACK)
 		return;
@@ -2748,6 +2752,13 @@ static void rs_get_rate(void *priv_r, struct ieee80211_sta *sta, void *priv_sta,
 	if (rate_control_send_low(sta, priv_sta, txrc))
 		return;
 
+	/* Exit if in a fixed-rate mode */
+	if (priv && priv->rotate_rates) {
+		info->control.rates[0].flags = 0;
+		info->control.rates[0].idx = 0;
+		return;
+	}
+
 	rate_idx  = lq_sta->last_txrate_idx;
 
 	if (lq_sta->last_rate_n_flags & RATE_MCS_HT_MSK) {
diff --git a/drivers/net/wireless/iwlwifi/dvm/rx.c b/drivers/net/wireless/iwlwifi/dvm/rx.c
index debec96..9e2e314 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rx.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rx.c
@@ -36,6 +36,7 @@
 #include "dev.h"
 #include "calib.h"
 #include "agn.h"
+#include "connector.h"
 
 #define IWL_CMD_ENTRY(x) [x] = #x
 
@@ -114,6 +115,7 @@ const char *const iwl_dvm_cmd_strings[REPLY_MAX] = {
 	IWL_CMD_ENTRY(REPLY_WOWLAN_KEK_KCK_MATERIAL),
 	IWL_CMD_ENTRY(REPLY_WOWLAN_GET_STATUS),
 	IWL_CMD_ENTRY(REPLY_D3_CONFIG),
+	IWL_CMD_ENTRY(REPLY_BFEE_NOTIFICATION),
 };
 #undef IWL_CMD_ENTRY
 
@@ -372,10 +374,17 @@ static void iwlagn_rx_calc_noise(struct iwl_priv *priv)
 	}
 
 	/* Average among active antennas */
-	if (num_active_rx)
+	if (num_active_rx) {
 		last_rx_noise = (total_silence / num_active_rx) - 107;
-	else
+		if (priv->connector_log & IWL_CONN_NOISE_MSK)
+			connector_send_msg((void *)&last_rx_noise,
+					sizeof(last_rx_noise), IWL_CONN_NOISE);
+	} else
 		last_rx_noise = IWL_NOISE_MEAS_NOT_AVAILABLE;
+	priv->last_rx_noise = last_rx_noise;
+	priv->last_rx_noiseA = bcn_silence_a;
+	priv->last_rx_noiseB = bcn_silence_b;
+	priv->last_rx_noiseC = bcn_silence_c;
 
 	IWL_DEBUG_CALIB(priv, "inband silence a %u, b %u, c %u, dBm %d\n",
 			bcn_silence_a, bcn_silence_b, bcn_silence_c,
@@ -659,11 +668,14 @@ static int iwlagn_rx_reply_rx_phy(struct iwl_priv *priv,
 				struct iwl_device_cmd *cmd)
 {
 	struct iwl_rx_packet *pkt = rxb_addr(rxb);
+	struct iwl_rx_phy_res *rx_phy_res = (void *)pkt->data;
 
 	priv->last_phy_res_valid = true;
 	priv->ampdu_ref++;
 	memcpy(&priv->last_phy_res, pkt->data,
 	       sizeof(struct iwl_rx_phy_res));
+	memcpy(&priv->last_cfg_phy_buf, rx_phy_res->cfg_phy_buf,
+			rx_phy_res->cfg_phy_cnt * sizeof(u32));
 	return 0;
 }
 
@@ -915,10 +927,12 @@ static int iwlagn_rx_reply_rx(struct iwl_priv *priv,
 	rx_pkt_status = *(__le32 *)(pkt->data + sizeof(*amsdu) + len);
 	ampdu_status = iwlagn_translate_rx_status(priv,
 						  le32_to_cpu(rx_pkt_status));
+	if (priv->connector_log & IWL_CONN_RX_MPDU_MSK)
+		connector_send_msg((void *)header, len, IWL_CONN_RX_MPDU);
 
-	if ((unlikely(phy_res->cfg_phy_cnt > 20))) {
-		IWL_DEBUG_DROP(priv, "dsp size out of range [0,20]: %d\n",
-				phy_res->cfg_phy_cnt);
+	if ((unlikely(phy_res->cfg_phy_cnt > IWLAGN_MAX_CFG_PHY_CNT))) {
+		IWL_DEBUG_DROP(priv, "dsp size out of range [0,%d]: %d\n",
+				IWLAGN_MAX_CFG_PHY_CNT, phy_res->cfg_phy_cnt);
 		return 0;
 	}
 
@@ -1092,6 +1106,9 @@ void iwl_setup_rx_handlers(struct iwl_priv *priv)
 	handlers[REPLY_COMPRESSED_BA]		=
 		iwlagn_rx_reply_compressed_ba;
 
+	/* Beamforming */
+	handlers[REPLY_BFEE_NOTIFICATION] = iwlagn_bfee_notif;
+
 	priv->rx_handlers[REPLY_TX] = iwlagn_rx_reply_tx;
 
 	/* set up notification wait support */
diff --git a/drivers/net/wireless/iwlwifi/dvm/rxon.c b/drivers/net/wireless/iwlwifi/dvm/rxon.c
index ed50de6..b498f77 100644
--- a/drivers/net/wireless/iwlwifi/dvm/rxon.c
+++ b/drivers/net/wireless/iwlwifi/dvm/rxon.c
@@ -530,6 +530,33 @@ static int iwlagn_rxon_connect(struct iwl_priv *priv,
 	return 0;
 }
 
+int iwlagn_send_dsp_debug(struct iwl_priv *priv)
+{
+	u32 count = 1;
+	size_t len = sizeof(struct iwl5000_dsp_debug) +
+		((count + 1) & ~1) * sizeof(u16);
+	struct iwl5000_dsp_debug *dsp_debug = kmalloc(len, GFP_ATOMIC);
+	u16 *mib_indices;
+	int ret;
+
+	if (!dsp_debug)
+		return -ENOMEM;
+
+	mib_indices = (u16 *) dsp_debug->mib_indices;
+
+	dsp_debug->mib_cnt = count;
+	dsp_debug->flags = DSP_DEBUG_OFDM_MSK;
+	dsp_debug->stat_id = 0;
+	dsp_debug->reserved = 0;
+	mib_indices[0] = OFDM_RX_ANT_OUT;
+
+	ret = iwl_dvm_send_cmd_pdu(priv, DSP_DEBUG_CMD, CMD_ASYNC, len,
+			dsp_debug);
+	kfree(dsp_debug);
+
+	return ret;
+}
+
 int iwlagn_set_pan_params(struct iwl_priv *priv)
 {
 	struct iwl_wipan_params_cmd cmd;
@@ -1062,6 +1089,12 @@ int iwlagn_commit_rxon(struct iwl_priv *priv, struct iwl_rxon_context *ctx)
 	if (!ctx->is_active)
 		return 0;
 
+	/* Enable beamforming */
+	if (priv->bf_enabled)
+		ctx->staging.flags |= RXON_FLG_BF_ENABLE_MSK;
+	else
+		ctx->staging.flags &= ~RXON_FLG_BF_ENABLE_MSK;
+
 	/* always get timestamp with Rx frame */
 	ctx->staging.flags |= RXON_FLG_TSF2HOST_MSK;
 
@@ -1145,6 +1178,11 @@ int iwlagn_commit_rxon(struct iwl_priv *priv, struct iwl_rxon_context *ctx)
 	if (ret)
 		return ret;
 
+	/* DSP debug command makes sure we get antenna selection information */
+	ret = iwlagn_send_dsp_debug(priv);
+	if (ret)
+		return ret;
+
 	ret = iwlagn_set_pan_params(priv);
 	if (ret)
 		return ret;
diff --git a/drivers/net/wireless/iwlwifi/dvm/sta.c b/drivers/net/wireless/iwlwifi/dvm/sta.c
index 6ec86ad..86dff6d 100644
--- a/drivers/net/wireless/iwlwifi/dvm/sta.c
+++ b/drivers/net/wireless/iwlwifi/dvm/sta.c
@@ -33,6 +33,7 @@
 #include "agn.h"
 
 const u8 iwl_bcast_addr[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+const u8 iwl_monitor_addr[ETH_ALEN] = { 0x00, 0x16, 0xEA, 0x12, 0x34, 0x56 };
 
 static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
 {
@@ -293,6 +294,8 @@ u8 iwl_prep_station(struct iwl_priv *priv, struct iwl_rxon_context *ctx,
 		sta_id = ctx->ap_sta_id;
 	else if (is_broadcast_ether_addr(addr))
 		sta_id = ctx->bcast_sta_id;
+	else if (is_monitor_ether_addr(addr))
+		sta_id = IWLAGN_MONITOR_ID;
 	else
 		for (i = IWL_STA_ID; i < IWLAGN_STATION_COUNT; i++) {
 			if (ether_addr_equal(priv->stations[i].sta.sta.addr,
@@ -1343,6 +1346,31 @@ int iwlagn_alloc_bcast_station(struct iwl_priv *priv,
 	priv->stations[sta_id].lq = link_cmd;
 	spin_unlock_bh(&priv->sta_lock);
 
+	/* Above: broadcast. Below: monitor */
+	spin_lock_bh(&priv->sta_lock);
+	sta_id = iwl_prep_station(priv, ctx, iwl_monitor_addr, false, NULL);
+	if (sta_id == IWL_INVALID_STATION) {
+		IWL_ERR(priv, "Unable to prepare monitor station\n");
+		spin_unlock_bh(&priv->sta_lock);
+
+		return -EINVAL;
+	}
+
+	priv->stations[sta_id].used |= IWL_STA_DRIVER_ACTIVE;
+	priv->stations[sta_id].used |= IWL_STA_BCAST;
+	spin_unlock_bh(&priv->sta_lock);
+
+	link_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);
+	if (!link_cmd) {
+		IWL_ERR(priv,
+			"Unable to initialize rate scaling for monitor station.\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_bh(&priv->sta_lock);
+	priv->stations[sta_id].lq = link_cmd;
+	spin_unlock_bh(&priv->sta_lock);
+
 	return 0;
 }
 
@@ -1372,6 +1400,23 @@ int iwl_update_bcast_station(struct iwl_priv *priv,
 	priv->stations[sta_id].lq = link_cmd;
 	spin_unlock_bh(&priv->sta_lock);
 
+	/* Above: broadcast. Below: monitor */
+	sta_id = IWLAGN_MONITOR_ID;
+
+	link_cmd = iwl_sta_alloc_lq(priv, ctx, sta_id);
+	if (!link_cmd) {
+		IWL_ERR(priv, "Unable to initialize rate scaling for monitor station.\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_bh(&priv->sta_lock);
+	if (priv->stations[sta_id].lq)
+		kfree(priv->stations[sta_id].lq);
+	else
+		IWL_DEBUG_INFO(priv, "Monitor station rate scaling has not been initialized yet.\n");
+	priv->stations[sta_id].lq = link_cmd;
+	spin_unlock_bh(&priv->sta_lock);
+
 	return 0;
 }
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/tx.c b/drivers/net/wireless/iwlwifi/dvm/tx.c
index 275df12..2e4e7ea 100644
--- a/drivers/net/wireless/iwlwifi/dvm/tx.c
+++ b/drivers/net/wireless/iwlwifi/dvm/tx.c
@@ -156,9 +156,23 @@ static void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv,
 	tx_cmd->data_retry_limit = data_retry_limit;
 	tx_cmd->rts_retry_limit = rts_retry_limit;
 
-	/* DATA packets will use the uCode station table for rate/antenna
-	 * selection */
-	if (ieee80211_is_data(fc)) {
+	/*
+	 * DATA packets will use the uCode station table for rate/antenna
+	 * selection.
+	 * ...
+	 * But handle some special experimental cases first
+	 */
+	if (ieee80211_is_data(fc) && priv->rotate_rates) {
+		tx_cmd->tx_flags &= ~TX_CMD_FLG_STA_RATE_MSK;
+		tx_cmd->rate_n_flags = cpu_to_le32(
+			priv->rotate_rate_array[priv->last_rotate_rate]);
+		priv->last_rotate_rate = (priv->last_rotate_rate + 1) %
+			priv->rotate_rate_total;
+		/* No retries in this mode */
+		tx_cmd->data_retry_limit = 0;
+		tx_cmd->rts_retry_limit = 0;
+		return;
+	} else if (ieee80211_is_data(fc)) {
 		tx_cmd->initial_rate_index = 0;
 		tx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;
 		return;
@@ -339,6 +353,8 @@ int iwlagn_tx_skb(struct iwl_priv *priv,
 			goto drop_unlock_priv;
 		}
 	}
+	if (sta == NULL && is_monitor_ether_addr(hdr->addr1))
+		sta_id = IWLAGN_MONITOR_ID;
 
 	if (sta)
 		sta_priv = (void *)sta->drv_priv;
@@ -380,7 +396,19 @@ int iwlagn_tx_skb(struct iwl_priv *priv,
 	/* TODO need this for burst mode later on */
 	iwlagn_tx_cmd_build_basic(priv, skb, tx_cmd, info, hdr, sta_id);
 
-	iwlagn_tx_cmd_build_rate(priv, tx_cmd, info, sta, fc);
+	/* If packet is to the monitor address, use the monitor rate; or
+	 * if packet is to the broadcast address, use the broadcast rate
+	 */
+	if ((IWLAGN_MONITOR_ID == sta_id) &&
+			(priv->monitor_tx_rate != 0)) {
+		tx_cmd->tx_flags &= ~TX_CMD_FLG_STA_RATE_MSK;
+		tx_cmd->rate_n_flags = cpu_to_le32(priv->monitor_tx_rate);
+	} else if ((ctx->bcast_sta_id == sta_id) &&
+			(priv->bcast_tx_rate != 0)) {
+		tx_cmd->tx_flags &= ~TX_CMD_FLG_STA_RATE_MSK;
+		tx_cmd->rate_n_flags = cpu_to_le32(priv->bcast_tx_rate);
+	} else
+		iwlagn_tx_cmd_build_rate(priv, tx_cmd, info, sta, fc);
 
 	memset(&info->status, 0, sizeof(info->status));
 
diff --git a/drivers/net/wireless/iwlwifi/iwl-5000.c b/drivers/net/wireless/iwlwifi/iwl-5000.c
index 724194e..df32cde 100644
--- a/drivers/net/wireless/iwlwifi/iwl-5000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-5000.c
@@ -35,7 +35,7 @@
 #define IWL5150_UCODE_API_MAX 2
 
 /* Oldest version we won't warn about */
-#define IWL5000_UCODE_API_OK 5
+#define IWL5000_UCODE_API_OK 2
 #define IWL5150_UCODE_API_OK 2
 
 /* Lowest firmware API version supported */
diff --git a/drivers/net/wireless/iwlwifi/iwl-drv.c b/drivers/net/wireless/iwlwifi/iwl-drv.c
index 7267152..c71a89b 100644
--- a/drivers/net/wireless/iwlwifi/iwl-drv.c
+++ b/drivers/net/wireless/iwlwifi/iwl-drv.c
@@ -1154,6 +1154,12 @@ static void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)
 		api_ver = IWL_UCODE_API(drv->fw.ucode_ver);
 
 	/*
+	 * Dan -- disable firmware version checks. Instead, verify
+	 * that the firmware has the size expected for the hacked firmware
+	 */
+	(void)api_min; /* Dan -- remove warning */
+#if 0
+	/*
 	 * api_ver should match the api version forming part of the
 	 * firmware filename ... but we don't check for that and only rely
 	 * on the API version read from firmware header from here on forward
@@ -1181,6 +1187,12 @@ static void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)
 				      "http://www.intellinuxwireless.org/.\n");
 		}
 	}
+#endif
+
+	if (ucode_raw->size != 336252) {
+		IWL_ERR(drv,
+			"Firmware size does not match iwlwifi-5000-2.ucode.sigcomm2010. The UW 802.11n CSI Tool will not work.\n");
+	}
 
 	/*
 	 * In mvm uCode there is no difference between data and instructions
@@ -1454,6 +1466,9 @@ struct iwl_mod_params iwlwifi_mod_params = {
 	.restart_fw = true,
 	.bt_coex_active = true,
 	.power_level = IWL_POWER_INDEX_1,
+#ifdef CONFIG_IWLWIFI_DEBUG
+	.debug_level = IWL_DL_FW_ERRORS,
+#endif
 	.d0i3_disable = true,
 #ifndef CONFIG_IWLWIFI_UAPSD
 	.uapsd_disable = true,
@@ -1548,6 +1563,10 @@ module_param_named(debug, iwlwifi_mod_params.debug_level, uint,
 MODULE_PARM_DESC(debug, "debug output mask");
 #endif
 
+module_param_named(connector_log, iwlwifi_mod_params.connector_log, int,
+		S_IRUGO);
+MODULE_PARM_DESC(connector_log,
+		"set connector log mask (default 0 [nothing])");
 module_param_named(swcrypto, iwlwifi_mod_params.sw_crypto, int, S_IRUGO);
 MODULE_PARM_DESC(swcrypto, "using crypto in software (default 0 [hardware])");
 module_param_named(11n_disable, iwlwifi_mod_params.disable_11n, uint, S_IRUGO);
diff --git a/drivers/net/wireless/iwlwifi/iwl-modparams.h b/drivers/net/wireless/iwlwifi/iwl-modparams.h
index ac2b90d..bafed7f 100644
--- a/drivers/net/wireless/iwlwifi/iwl-modparams.h
+++ b/drivers/net/wireless/iwlwifi/iwl-modparams.h
@@ -95,12 +95,13 @@ enum iwl_disable_11n {
  * @disable_11n: disable 11n capabilities, default = 0,
  *	use IWL_[DIS,EN]ABLE_HT_* constants
  * @amsdu_size_8K: enable 8K amsdu size, default = 0
+ * @connector_log: which connector messages, default = 0
  * @restart_fw: restart firmware, default = 1
  * @bt_coex_active: enable bt coex, default = true
  * @led_mode: system default, default = 0
  * @power_save: enable power save, default = false
  * @power_level: power level, default = 1
- * @debug_level: levels are IWL_DL_*
+ * @debug_level: levels are IWL_DL_*, default = IWL_DL_FW_ERRORS
  * @ant_coupling: antenna coupling in dB, default = 0
  * @d0i3_disable: disable d0i3, default = 1,
  * @lar_disable: disable LAR (regulatory), default = 0
@@ -111,6 +112,7 @@ struct iwl_mod_params {
 	unsigned int disable_11n;
 	int amsdu_size_8K;
 	bool restart_fw;
+	int connector_log;
 	bool bt_coex_active;
 	int led_mode;
 	bool power_save;
diff --git a/drivers/net/wireless/iwlwifi/iwl-trans.h b/drivers/net/wireless/iwlwifi/iwl-trans.h
index 56254a8..bb39263 100644
--- a/drivers/net/wireless/iwlwifi/iwl-trans.h
+++ b/drivers/net/wireless/iwlwifi/iwl-trans.h
@@ -316,7 +316,7 @@ static inline void iwl_free_rxb(struct iwl_rx_cmd_buffer *r)
 	__free_pages(r->_page, r->_rx_page_order);
 }
 
-#define MAX_NO_RECLAIM_CMDS	6
+#define MAX_NO_RECLAIM_CMDS	7
 
 #define IWL_MASK(lo, hi) ((1 << (hi)) | ((1 << (hi)) - (1 << (lo))))
 
